import{_ as o,c as e,o as t,a1 as a}from"./chunks/framework.EKgu3izQ.js";const g=JSON.parse('{"title":"前端-html","description":"","frontmatter":{},"headers":[],"relativePath":"code/front/html.md","filePath":"code/front/html.md"}'),r={name:"code/front/html.md"},l=a('<h1 id="前端-html" tabindex="-1">前端-html <a class="header-anchor" href="#前端-html" aria-label="Permalink to &quot;前端-html&quot;">​</a></h1><h2 id="渲染与性能知识" tabindex="-1">渲染与性能知识 <a class="header-anchor" href="#渲染与性能知识" aria-label="Permalink to &quot;渲染与性能知识&quot;">​</a></h2><h3 id="回流重绘" tabindex="-1">回流重绘 <a class="header-anchor" href="#回流重绘" aria-label="Permalink to &quot;回流重绘&quot;">​</a></h3><p><code>回流</code>：改变几何属性的渲染；</p><p><code>重绘</code>：改变外观属性而不影响几何属性的渲染。</p><p>当生成渲染树后，至少会渲染一次，在后续交互时还会不断的重新渲染。这时只会回流重绘或只有重绘，因此引出一个定向法则：<code>回流必定引发重绘，重绘不一定引发回流</code>。</p><h3 id="网页的渲染过程" tabindex="-1">网页的渲染过程 <a class="header-anchor" href="#网页的渲染过程" aria-label="Permalink to &quot;网页的渲染过程&quot;">​</a></h3><ul><li><strong>解析文件</strong></li><li><strong>DOM树</strong>：将html文件转换为<code>DOM</code>树（<code>Document Object Model</code>）</li><li><strong>CSSOM树</strong>：将css文件转换为<code>CSSOM</code>树</li><li><strong>渲染树</strong>：将DOM树与CSSOM树合并生成渲染树</li><li><strong>绘制图层</strong></li><li><strong>回流</strong>：根据渲染树生成布局渲染树</li><li><strong>重绘</strong>：根据布局渲染树生成绘制渲染树</li><li><strong>合成图层</strong>：根据绘制渲染树合成图层显示在屏幕中</li></ul><h3 id="前端性能制约与优化" tabindex="-1">前端性能制约与优化 <a class="header-anchor" href="#前端性能制约与优化" aria-label="Permalink to &quot;前端性能制约与优化&quot;">​</a></h3><p>前端制约快速响应性能的场景可以概括为两类：</p><ul><li><p>CPU的瓶颈</p></li><li><p>IO的瓶颈</p></li></ul><p>当项目庞大，组件繁多时，就容易遇到CPU瓶颈。</p><p>主流浏览器刷新频率为<code>60HZ</code>，即每（<code>1000ms/60Hz</code>） <code>16.6ms</code>浏览器刷新一次。</p><p>JS可以操作DOM，<code>GUI渲染线程与JS线程是互斥的</code>，所以<code>JS脚本执行和浏览器布局、绘制不能同时执行</code>。</p><p>在每16.6ms时间内，需要完成如下工作：</p><p><code>JS脚本执行 --- 样式布局 --- 样式绘制</code></p><p>当js执行时间过长，没有时间执行样式布局和样式绘制了，就会造成页面掉帧卡顿。</p><p><strong>io的瓶颈，网络延迟是前端开发者无法解决的</strong>，如何减少用户对网络延迟的感知？可以<strong>将人机交互研究的结果整合到真实的UI中</strong>。</p><p>比如：点击搜索后，先在当前页面停留了一小段时间，这一小段时间被用来请求数据。</p><p>当“这一小段时间”足够短时，用户是无感知的。如果请求时间超过一个范围，再显示loading的效果。</p><p>试想如果我们一点击“Siri 与搜索”就显示loading效果，即使数据请求时间很短，loading效果一闪而过。用户也是可以感知到的。</p>',21),n=[l];function c(d,i,s,p,h,m){return t(),e("div",null,n)}const u=o(r,[["render",c]]);export{g as __pageData,u as default};
